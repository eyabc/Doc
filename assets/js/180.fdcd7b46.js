(window.webpackJsonp=window.webpackJsonp||[]).push([[180],{587:function(t,_,v){"use strict";v.r(_);var e=v(44),d=Object(e.a)({},(function(){var t=this,_=t.$createElement,v=t._self._c||_;return v("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[v("h1",{attrs:{id:"_5장-제네릭-generic"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#_5장-제네릭-generic"}},[t._v("#")]),t._v(" 5장 제네릭 Generic")]),t._v(" "),v("ul",[v("li",[t._v("자바 5에 등장")])]),t._v(" "),v("h2",{attrs:{id:"제네릭-이전"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#제네릭-이전"}},[t._v("#")]),t._v(" 제네릭 이전")]),t._v(" "),v("ul",[v("li",[t._v("컬렉션에서 객체를 꺼낼 때마다 형변환 필요")]),t._v(" "),v("li",[t._v("런타임에서 형변환 오류 발견")])]),t._v(" "),v("h2",{attrs:{id:"제네릭-이후"}},[v("a",{staticClass:"header-anchor",attrs:{href:"#제네릭-이후"}},[t._v("#")]),t._v(" 제네릭 이후")]),t._v(" "),v("ul",[v("li",[t._v("컬렉션이 담을 수 있는 타입을 컴파일러에게 알려줄 수 있음")]),t._v(" "),v("li",[t._v("컴파일러가 자동으로 형변환 코드를 추가해 줄 수 있다.")]),t._v(" "),v("li",[t._v("컴파일 과정에서 형변환 오류를 발견할 수 있다.")])]),t._v(" "),v("p",[t._v("제네릭은 코드가 복잡해진다는 단점이 있으나, 이번 장에서 제네릭의 이점을 살리고 단점을 최소화 하는 방법을 서술한다.")]),t._v(" "),v("table",[v("thead",[v("tr",[v("th",[t._v("한글 용어")]),t._v(" "),v("th",[t._v("영문 용어")]),t._v(" "),v("th",[t._v("예")])])]),t._v(" "),v("tbody",[v("tr",[v("td",[t._v("매개변수화 타입")]),t._v(" "),v("td",[t._v("parameterized type")]),t._v(" "),v("td",[v("code",[t._v("List<String>")])])]),t._v(" "),v("tr",[v("td",[t._v("실제 타입 매개변수")]),t._v(" "),v("td",[t._v("actual type parameter")]),t._v(" "),v("td",[v("code",[t._v("String")])])]),t._v(" "),v("tr",[v("td",[t._v("제네릭 타입")]),t._v(" "),v("td",[t._v("generic type")]),t._v(" "),v("td",[v("code",[t._v("List<E>")])])]),t._v(" "),v("tr",[v("td",[t._v("정규 타입 매개변수")]),t._v(" "),v("td",[t._v("formal type parameter")]),t._v(" "),v("td",[v("code",[t._v("E")])])]),t._v(" "),v("tr",[v("td",[t._v("비한정적 와일드카드 타입")]),t._v(" "),v("td",[t._v("unbounded wildcard type")]),t._v(" "),v("td",[v("code",[t._v("List<?>")])])]),t._v(" "),v("tr",[v("td",[t._v("로타입")]),t._v(" "),v("td",[t._v("raw type")]),t._v(" "),v("td",[v("code",[t._v("List")])])]),t._v(" "),v("tr",[v("td",[t._v("한정적 타입 매개변수")]),t._v(" "),v("td",[t._v("bounded type parameter")]),t._v(" "),v("td",[v("code",[t._v("<E extends Number>")])])]),t._v(" "),v("tr",[v("td",[t._v("재귀적 타입 한정")]),t._v(" "),v("td",[t._v("recursive type bound")]),t._v(" "),v("td",[v("code",[t._v("<T extends Comparable<T>>")])])]),t._v(" "),v("tr",[v("td",[t._v("한정적 와일드 카드 타입")]),t._v(" "),v("td",[t._v("bounded wildcard type")]),t._v(" "),v("td",[v("code",[t._v("List<? extends Number>")])])]),t._v(" "),v("tr",[v("td",[t._v("제네릭 메서드")]),t._v(" "),v("td",[t._v("generic method")]),t._v(" "),v("td",[v("code",[t._v("static <E> List<E> asList(E[] a)")])])]),t._v(" "),v("tr",[v("td",[t._v("타입 토큰")]),t._v(" "),v("td",[t._v("type token")]),t._v(" "),v("td",[v("code",[t._v("String.class")])])])])])])}),[],!1,null,null,null);_.default=d.exports}}]);