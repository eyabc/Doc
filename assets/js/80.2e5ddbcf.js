(window.webpackJsonp=window.webpackJsonp||[]).push([[80],{482:function(t,a,r){"use strict";r.r(a);var e=r(44),v=Object(e.a)({},(function(){var t=this,a=t.$createElement,r=t._self._c||a;return r("ContentSlotsDistributor",{attrs:{"slot-key":t.$parent.slotKey}},[r("h1",{attrs:{id:"const-let-var"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#const-let-var"}},[t._v("#")]),t._v(" const let var")]),t._v(" "),r("h2",{attrs:{id:"const-let"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#const-let"}},[t._v("#")]),t._v(" const let")]),t._v(" "),r("h3",{attrs:{id:"차이"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#차이"}},[t._v("#")]),t._v(" 차이")]),t._v(" "),r("ul",[r("li",[t._v("let\n"),r("ul",[r("li",[r("code",[t._v("변수")]),t._v(" 선언")]),t._v(" "),r("li",[t._v("재대입 가능.")])])]),t._v(" "),r("li",[t._v("const\n"),r("ul",[r("li",[r("code",[t._v("상수")]),t._v(" 선언")]),t._v(" "),r("li",[t._v("재대입 불가능")]),t._v(" "),r("li",[t._v("규칙 : 선언과 동시에 대입\n"),r("ul",[r("li",[t._v("nor "),r("code",[t._v("Reference Error")])])])])])])]),t._v(" "),r("h3",{attrs:{id:"공통점"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#공통점"}},[t._v("#")]),t._v(" 공통점")]),t._v(" "),r("h4",{attrs:{id:"같은-이름을-갖는-변수의-재선언을-허용하지-않는다"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#같은-이름을-갖는-변수의-재선언을-허용하지-않는다"}},[t._v("#")]),t._v(" 같은 이름을 갖는 변수의 재선언을 허용하지 않는다.")]),t._v(" "),r("ul",[r("li",[t._v("Q: 같은 이름을 갖는 변수를 재선언 했을때의 문제점은 무엇인가요?\n"),r("ul",[r("li",[t._v("일반적으로 같은 스코프에 같은 이름의 변수를 선언하는 것은 실수일 가능성이 높기 때문에 미리 검출해준다.\n"),r("a",{attrs:{href:"https://books.google.co.kr/books?id=QeUlDwAAQBAJ&pg=PA75&lpg=PA75&dq=%EA%B0%99%EC%9D%80+%EC%9D%B4%EB%A6%84%EC%9C%BC%EB%A1%9C+%EC%9E%AC%EC%84%A0%EC%96%B8+%EB%AC%B8%EC%A0%9C%EC%A0%90&source=bl&ots=vOAlIAFtnS&sig=ACfU3U3cB0rAGAmv-3u4LjxiL9GyC2MGDg&hl=ko&sa=X&ved=2ahUKEwjTst6Qy7jqAhWCA4gKHbfSDw4Q6AEwAHoECAoQAQ#v=onepage&q=%EA%B0%99%EC%9D%80%20%EC%9D%B4%EB%A6%84%EC%9C%BC%EB%A1%9C%20%EC%9E%AC%EC%84%A0%EC%96%B8%20%EB%AC%B8%EC%A0%9C%EC%A0%90&f=false",target:"_blank",rel:"noopener noreferrer"}},[t._v("🔗"),r("OutboundLink")],1)]),t._v(" "),r("li",[t._v("같은 스코프 내의 변수는 다시 재선언 할 필요 없이, 값을 재할당 하여 쓰면 된다.")])])]),t._v(" "),r("li",[t._v("Q: 같은 이름을 let으로 선언하고, var로 재선언 할 수 있나요?\n"),r("ul",[r("li",[t._v("A: Uncaught SyntaxError: Identifier 'hi' has already been declared")])])]),t._v(" "),r("li",[t._v("Q: 같은 이름을 var으로 선언하고, let로 재선언 할 수 있나요?\n"),r("ul",[r("li",[t._v("A: Uncaught SyntaxError: Identifier 'a' has already been declared")])])])]),t._v(" "),r("h4",{attrs:{id:"블록-스코프"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#블록-스코프"}},[t._v("#")]),t._v(" 블록 스코프")]),t._v(" "),r("ul",[r("li",[t._v("if, for, while { ... }")]),t._v(" "),r("li",[t._v("자세한 내용은 아래에있다.")])]),t._v(" "),r("h4",{attrs:{id:"변수가-선언되기-전에-참조하려고-하면-에러가-난다"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#변수가-선언되기-전에-참조하려고-하면-에러가-난다"}},[t._v("#")]),t._v(" 변수가 선언되기 전에 참조하려고 하면 에러가 난다.")]),t._v(" "),r("ul",[r("li",[t._v("let과 const는 변수가 선언되기 전에 참조할 수 없는 규칙이 있다.")]),t._v(" "),r("li",[t._v("Q: 왜 이런 규칙을 만들었을까요?\n"),r("ul",[r("li",[t._v("A : 변수를 선언하지 않았는데 사용한게 프로그래밍 적 오류 이다.")]),t._v(" "),r("li",[t._v("이 문제는 런타임 환경(서비스 도중)에서 발견할 수 있다는 문제점")])])])]),t._v(" "),r("h2",{attrs:{id:"var-vs-let-const"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#var-vs-let-const"}},[t._v("#")]),t._v(" var vs let, const")]),t._v(" "),r("h3",{attrs:{id:"var"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#var"}},[t._v("#")]),t._v(" var")]),t._v(" "),r("ul",[r("li",[t._v("재선언 가능")]),t._v(" "),r("li",[t._v("선언 전에 참조 가능(undefined)\n"),r("ul",[r("li",[t._v("var 를 지양해야된다.")])])]),t._v(" "),r("li",[t._v("함수 스코프 function () {}")])]),t._v(" "),r("h3",{attrs:{id:"let-const"}},[r("a",{staticClass:"header-anchor",attrs:{href:"#let-const"}},[t._v("#")]),t._v(" let, const")]),t._v(" "),r("ul",[r("li",[t._v("재선언 불가능")]),t._v(" "),r("li",[t._v("블록 스코프")]),t._v(" "),r("li",[t._v("선언 전에 참조 불가(Reference Error)")])])])}),[],!1,null,null,null);a.default=v.exports}}]);